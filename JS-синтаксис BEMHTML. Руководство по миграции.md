#JS-синтаксис BEMHTML. Руководство по миграции.

<a id="intro"></a>
##Введение

Документ предназначен для веб-разработчиков и HTML-верстальщиков, использующих [БЭМ-методологию](http://ru.bem.info/method/) и шаблонизатор BEMHTML.

В документе описаны:	

* совместимость BEMHTML шаблонов, реализованных в разном синтаксисе;
* реализация в JS-синтаксисе стандартных операций шаблонизатора BEMHTML;
* режимы выполнения шаблонов;


В документе не описаны настройка среды разработки и процедуры компиляции шаблонов, особенности шаблонизатора BEMHTML, формат входных данных BEMJSON.


<a id="general"></a>
##Общие сведения

С версии v.1.0 в библиотеку bem-core, была добавлена возможность исполнять BEMHTML-шаблоны, написанные в JavaScript-синтаксисе.

В библиотеке поддерживается как **традиционный**, так и JS- синтаксисы. С момента выпуска библиотеки bem-core традиционный синтаксис шаблонов считается устаревшим. 

JavaScript-синтаксис BEMHTML-шаблонов имеет следующие преимущества:

* более высокая скорость работы шаблонизатора; 
* подсветка синтаксиса в различных средах разработки;
* может выполняться тот же код, который пишется. Это упрощает поиск ошибок и отладку;
* исключена повторная компиляция при изменении шаблона.


Шаблонизатор BEMHTML при использовании с шаблонами, созданными в JS-синтаксисе, сохраняет все ключевые особенности.

***

<a id="install"></a>
##Подключение

Возможность исполнения BEMHTML-шаблонов с JS-синтаксисом доступна  во всех компонентах БЭМ-платформы, использующих `bem-core`.

Для перехода на JS-синтаксис можно:

* воспользоваться версией `project-stub`, использующей `bem-core` (ветка [bem-core](https://github.com/bem/project-stub/tree/bem-core)) ;
* использовать пакет [bem-tools v1.0](https://github.com/bem/bem-tools/tree/release-1.0.0).
* самостоятельно установить необходимые пакеты -- [bem-xjst](https://github.com/bem/bem-xjst), [bemhtml-compat](https://github.com/bem/bemhtml-compat), модуль технологии [BEMHTML API v2](https://github.com/bem/bem-core/blob/v1/.bem/techs/bemhtml.js).

Модуль технологии `BEMHTML`, поддерживающий JS-синтаксис, реализован с [API v2 технологии](http://ru.bem.info/tools/bem/bem-tools/tech-modules/#%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-api-v2-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8) bem-tools. Для использования его в проекте требуется пакет bem-tools с версией не ниже 0.6.4.

***


<a id="compat"></a>
##Совместимость шаблонов

BEMHTML-шаблоны, реализованные в разном синтаксисе, могут использоваться в одном проекте.

В процессе выполнения, шаблонизатор приводит шаблоны, созданные в разном синтаксисе к общему виду. Подробнее об этом читайте в разделе [Выполнение шаблонов](#run).

Шаблонизатор определяет синтаксис, в котором реализован файл шаблона по суффиксу:

 * для традиционного синтаксиса  -- суффикс `.bemhtml`;
 * для JS-синтаксиса  -- суффикс `.bemhtml.xjst`.


При использовании в проекте шаблонов, реализованных в разном синтаксисе, обратите внимание на следующие особенности:

* файлы BEMHTML шаблонов в блоках должны иметь суффикс, соответствующий синтаксису, в котором они реализованы;
* не рекомендуется использовать в файле шаблона оба синтаксиса одновременно. Точнее, в файле шаблона с суффиксом `.bemhtml` могут присутствовать фрагменты кода в JS-синтаксисе, но не наоборот.

**NB** Шаблоны можно автоматически преобразованы из традиционного в JS-синтаксис. Для этого служит модуль [BEMHTML-COMPAT](https://github.com/bem/bemhtml-compat). Но шаблоны, полученные в результате такого преобразования, сложны для восприятия. Это затрудняет их дальнейшую разработку и поддержку. 

***

<a id="runmode"></a>
##Режимы выполнения шаблонов

Шаблонизатор BEMHTML может работать в двух режимах, в зависимости от настроек сборки:

* режиме разработки (dev-режим);
* режиме продакшен.

Режимы влияют на ход выполнения шаблонов, реализованных как в классическом, так и в JS- синтаксисах.

Основная разница между режимами в том, что в продакшен режиме производятся XJST-преобразования шаблонов, в результате которых на выходе получается оптимизированный JavaScript. Это увеличивает время сборки проекта (за счет компиляции) но, в дальнейшем, повышает скорость выполнения шаблонов.

Режим выполнения выбирается шаблонизатором на основании значения переменной окружения `process.env.BEMHTML_ENV`. При ее значении равном `'development'` используется режим разработки.

По умолчанию в bem-tools v1.0 используется dev-режим.

Подробнее о настройках среды разработки читайте [здесь](#).


<a id="run"></a>
##Выполнение шаблонов

Работа шаблонизатора BEMHTML происходит в два этапа:

* подготовительный этап;
* основной этап.


<a id="runpre"></a>
###Подготовительный этап

Действия, производимые шаблонизатором на подготовительном этапе различаются в зависимости от синтаксиса шаблонов и выбранного режима выполнения.


<a id="runclassic"></a>
####Традиционный синтаксис

Для шаблонов, реализованных в традиционном синтаксисе, в зависимости от режима выполнения производятся следующие действия: 

* **в режиме разработки**:
	* производится компиляция, преобразующая шаблоны в XJST-синтаксис;
	* все BEMHTML шаблоны, участвующие в сборке, собираются в общий рантайм бандл;
	* запускается основной этап.
* **в продакшен-режиме**: 
	* производится компиляция, преобразующая шаблоны в XJST-синтаксис;
	* все BEMHTML шаблоны, участвующие в сборке, собираются в общий рантайм бандл;
	* выполняются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript;
	* запускается основной этап.


<a id="runjs"></a>
####JavaScript-синтаксис

* **в режиме разработки**:
	* все BEMHTML шаблоны, участвующие в сборке, собираются в общий рантайм бандл;
	* запускается основной этап.
* **в продакшен-режиме**: 
	* все BEMHTML шаблоны, участвующие в сборке, собираются в общий рантайм бандл;
	* выполняются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript;
	* запускается основной этап.


<a id="runmain"></a>
###Основной этап

Основной этап одинаков для всех синтаксисов и режимов выполнения:

* шаблонизатор принимает на вход БЭМ-дерево в формате BEMJSON;
* последовательно обходит узлы входного БЭМ-дерева;
* в процессе обхода входного BEMJSON-дерева строит структуру данных -- [контекст](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#context)
* выполняет цикл генерации выходного HTML-элемента для каждой БЭМ-сущности;
* рекурсивно выполняет цикл генерации выходных HTML-элементов для вложенных БЭМ-сущностей; 
* поэлементно выполняет запись в буфер HTML-результата (this._buf.push(…)).

***


<a id="sintax"></a>
##JavaScript-cинтаксис BEMHTML шаблонов

Чтобы упростить создание BEMHTML-шаблонов с JavaScript-синтаксисом, используется технология [BEM-XJST](https://github.com/bem/bem-xjst).

BEM-XJST это набор БЭМ-ориентированных хелперов, расширяющий стандартный XJST-синтаксис. Для BEMHTML-шаблонов в JS-синтаксисе он позволяет:

  * использовать хелперы для записи подпредикатов, относящихся к предметной области БЭМ; 
  * писать вложенные шаблоны;
  * использовать хелперы для определение подпредиката по моде.

BEM-XJST является надмножеством языка шаблонов XJST, который, в свою очередь, является надмножеством JavaScript.

BEM-XJST использует канонический XJST-синтаксис, расширенный набором правил, относящихся к предметной области БЭМ. Такая реализация позволяет в режиме разработки выполнять BEMHTML шаблоны, написанные в JS-синтаксисе, без предварительной компиляции.

***

<a name="template"></a>

#### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен тогда и только тогда, когда истинны все подпредикаты. 


В традиционном синтаксисе предикат и тело разделяются двоеточием, а подпредикаты -- запятыми:

```
подпредикат1, подпредикат2, подпредикат3: тело
```

В JS-синтаксисе для работы с шаблоном вводится ключевое слово `match`. 

Ключевое слово `match` -- это метод-хелпер, принимающий аргументом перечень подпредикатов. Возвращаемым значением метода является функция от одного аргумента -- тела шаблона.

```
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Например:

```(js)
match(this.block === 'link', this._mode === 'tag', this.ctx.url)('a');
```

Так же, набор подпредикатов может быть записан каскадом:

```(js)
match(this.block === 'link').match(this._mode === 'tag').match(this.ctx.url)('a');
```

Приведенные выше примеры тождественны и соответствуют следующей записи в традиционном синтаксисе:

```
block link, tag, this.ctx.url: 'a'
```

----
**NB** Если для данного контекста определено более одного шаблона, то выполняется **последний** в порядке перечисления в BEMHTML-файле.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.
***


<a name="podpredicate"></a>

#### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEMHTML предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для этого в предикатах используются следующие ключевые слова:

**Блок**.

Ключевое слово:
* классический синтаксис -- `block`
* JS-синтаксис -- `block`

Аргументы:
* имя блока

Пример в классическом синтаксисе:
```
block b-menu, block 'b-menu', block 'b' + '-menu'
```

Пример в JS-синтаксисе:
```(js)
block('b-menu'), block("b-menu"), block('b' + '-menu')
```

**Элемент**.

Ключевое слово:
* классический синтаксис -- `elem`
* JS-синтаксис -- `elemMatch`

Аргументы:
* имя элемента

Пример в классическом синтаксисе:
```
block b-menu, elem item
```

Пример в JS-синтаксисе:
```(js)
block('b-menu')(elemMatch('item')), block('b-menu').elemMatch('item')
```

**Модификатор блока**.

Ключевое слово:
* классический синтаксис -- `mod`
* JS-синтаксис -- `mod`

Аргументы:
* имя модификатора блока;
* значение модификатора блока.

Пример в классическом синтаксисе:
```
block b-head-logo, mod size big
```

Пример в JS-синтаксисе:
```(js)
block('b-head-logo')(mod('size', 'big')),  block('b-head-logo').mod('size', 'big')
```

**Модификатор элемента**.

Ключевое слово:
* классический синтаксис -- `mods`
* JS-синтаксис -- `mods`

Аргументы:
* имя модификатора элемента;
* значение модификатора элемента.

Пример в классическом синтаксисе:
```
block b-head-logo, elem text, elemMod size big
```

Пример в JS-синтаксисе:
```(js)
block('b-head-logo')(elemMatch('text')(mods('size', 'big')))
```

Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть
указано любое JS-выражение, которое будет приведено к строке.


В JS-синтаксисе ключевые слова, относящиеся к БЭМ-предметной области, используются для сокращенной записи подпредикатов. 
В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.

Следующие предикаты тождественны:

```
match(this.block === 'foo').match(this.elem === 'bar')
```

```
block('foo').elemMatch('bar')
```


Ключевое слово `elemMatch` для записи произвольного подпредиката об элементе было добавлено, чтобы позволить выполнять шаблоны без компиляции:

```(js)
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```

Чтобы избежать срабатывания парсера на элементы, в процессе обработки шаблонов блоков, производится добавление кастомного подпредиката `!this.elem` к шаблонам, где нет подпредикатов, описывающих элементы. 

***


<a name="moda"></a>

##### Мода

В качестве подпредиката может выступать название одной из [стандартных мод](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#standardmoda). Это означает, что данный
предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:

* `default`
* `tag`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `attrs`
* `content`

В традиционном синтаксисе любой подпредикат, состоящий только из идентификатора (`[a-zA-Z0-9-]+`), интерпретируется как название
нестандартной моды. Например, подпредикат `my-mode` эквивалентен подпредикату `` this._mode === 'my-mode' ``.

В JS-синтаксисе, чтобы определить подпредикат по одной из стандартных мод можно воспользоваться хелпером, соответствующим ключевому слову. 

Например, выражение ``tag()('foo')`` эквивалентно выражению ``match(this._mode === 'tag')('foo')``.


***


##### Произвольное условие
<a name="random_condition"></a>

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.


В JS-синтаксисе для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```(js)
match(this.ctx.url)(
        tag()('a'), //выставляет текущей моду tag и передает 'a' аргументом
        attrs()({ href: this.ctx.url }) //выставляет текущей моду attrs и передает хеш аргументом 

    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, когда полю `url` в контексте присвоено значение. В этом случае будет выполнено тело шаблона.


***

<a name="body"></a>

#### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного HTML.
В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:

Традиционный синтаксис:

  ```
  предикат: JS-выражение
  ```
  
JS-синтаксис:
  ```
match(предикат)(JS-выражение)
  ```

* Блок JavaScript-кода, заключенный в фигурные скобки:

Традиционный синтаксис:
  ```
  предикат: { JS-блок }
  ```
  
JS-синтаксис:
  ```
match(предикат)({ JS-блок })
  ```


* Хеш, состоящий из пар ключ:значение, разделенных запятыми и заключенный в фигурные скобки:

Традиционный синтаксис:
```
предикат: ({name: value})
```

JS-синтаксис:
```
match(предикат)({имя: значение})
```

***


В JS-синтаксисе тело шаблона передается аргументом в функцию, возвращаемую методом `match` и хелперами для БЭМ-сущности или моды.

Синтаксис:

```
название-моды()(тело)

БЭМ-сущность()(тело)

match(произвольный предикат)(тело)
```

***



#### Вложенность шаблонов

Если несколько шаблонов имеют общие подпредикаты, они могут быть записаны в виде вложенной структуры для сокращения количества повторов в коде.

 Уровень вложенности подпредикатов не ограничен.

В традиционном синтаксисе для обозначения вложенности используются фигурные скобки. Фигурные скобки ставятся после общей части предикатов,
в них заключается блок кода, содержащий различающиеся части предикатов и соответствующие им тела шаблонов.

```
подпредикат1 {
  подпредикат2: тело1
  подпредикат3: тело2
}
```

Данная запись эквивалентна следующей:

```
подпредикат 1, подпредикат 2: тело1
подпредикат 1, подпредикат 3: тело2
```

В JS-синтаксисе возможна аналогичная запись вложенности:

```(js)
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

Данная запись эквивалентна следующей:

```(js)
match(this.block === 'link').match(this._mode === 'tag')('a');
match(this.block === 'link').match(this._mode === 'attrs')({ href: this.ctx.url });
```


Чтобы сделать запись более лаконичной могут использоваться хелперы для БЭМ-сущностей и названий стандартных мод.

Например шаблон:

```(js)
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

может быть записан в виде:

```(js)
block('link')(
    tag()('a'),
    attrs()({ href: this.ctx.url })
)
```

В BEMHTML-шаблонах можно выкладывать на один уровень тело шаблона и подшаблоны.

В традиционном синтаксисе для реализации такой возможности использовалось ключевое слово `true`:

```
this.ctx.url {
    true: 'a'
    mods not-link yes: 'span'
}
```

В JS-синтаксисе тело шаблона передается хелперу первым аргументом, а подшаблоны следующими:

```(js)
match(this.ctx.url)(
    'a',
    mods('not-link', 'yes')('span')
)
```


Глубина вложенности подшаблонов не ограничена:

```(js)
block('link')(
    tag()('span'),
    match(this.ctx.url)(
        tag()('a'),
        attrs()({ href: this.ctx.url })
    )
)
```

**NB** Не рекомендуется использовать для записи вложенных подшаблонов тернарный оператор или условные операторы JavaScript. Такие конструкции не будут оптимизированы в продакшен режиме.
***

