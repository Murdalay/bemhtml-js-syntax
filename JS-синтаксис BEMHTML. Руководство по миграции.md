#JS-синтаксис BEMHTML. Руководство по миграции.

<a id="intro"></a>
##Введение

Документ предназначен для веб-разработчиков и HTML-верстальщиков, использующих [БЭМ-методологию](http://ru.bem.info/method/) и [шаблонизатор BEMHTML](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/).

В документе описаны:	

* [совместимость](#compat) BEMHTML шаблонов, реализованных в разном синтаксисе;
* настройки [среды исполнения шаблонов](#runmode);
* схема [обработки BEMHTML-шаблонов](#run);
* реализация в [JavaScript-синтаксисе](#sintax) стандартных операций шаблонизатора BEMHTML;

В документе не описаны настройка среды разработки и процедуры компиляции шаблонов, особенности шаблонизатора BEMHTML, формат входных данных [BEMJSON](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#bemjson).


<a id="general"></a>
##Общие сведения

С версии v.1.0 в библиотеку [bem-core](https://github.com/bem/bem-core/tree/v1), была добавлена возможность исполнять BEMHTML-шаблоны, написанные в JavaScript-синтаксисе.

В библиотеке поддерживается как **сокращенный**, так и JS- синтаксисы. С момента выпуска библиотеки bem-core сокращенный синтаксис шаблонов считается устаревшим. 

JavaScript-синтаксис BEMHTML-шаблонов имеет следующие преимущества:

* поддержка синтаксиса различными средами разработки и инструментами (т.к. код — обычный JavaScript):
	* подсветка кода;
	* JSHint, JSLint, etc. 
* может выполняться тот же код, который пишется (в [dev-среде исполнения](#runmode)). Это упрощает поиск ошибок и отладку;
* более высокая скорость [компиляции](#run) (особенно в dev-среде исполнени).

Шаблонизатор BEMHTML при использовании с шаблонами, созданными в JS-синтаксисе, сохраняет все ключевые особенности.

***

<a id="install"></a>
##Подключение

Возможность исполнения BEMHTML-шаблонов с JS-синтаксисом доступна  во всех компонентах БЭМ-платформы, использующих `bem-core`.

Для перехода на JS-синтаксис можно:

* воспользоваться версией `project-stub`, использующей `bem-core` (ветка [bem-core](https://github.com/bem/project-stub/tree/bem-core));
* самостоятельно установить необходимые пакеты — [bem-xjst](https://github.com/bem/bem-xjst), [bemhtml-compat](https://github.com/bem/bemhtml-compat), модуль технологии пакеиа bem-tools [BEMHTML API v2](https://github.com/bem/bem-core/blob/v1/.bem/techs/bemhtml.js).

Модуль технологии `BEMHTML`, поддерживающий JS-синтаксис, реализован с [API v2 технологии](http://ru.bem.info/tools/bem/bem-tools/tech-modules/#%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-api-v2-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8) bem-tools. Для использования его в проекте требуется пакет bem-tools с версией не ниже 0.6.4.

***


<a id="compat"></a>
##Совместимость шаблонов

BEMHTML-шаблоны, реализованные в разном синтаксисе, могут использоваться в одном проекте.

В процессе выполнения, шаблонизатор приводит шаблоны, созданные в сокращенный синтаксисе к JS-синтаксису. Подробнее об этом читайте в разделе [Выполнение шаблонов](#run).

В ходе парсинга шаблонизатор автоматически определяет синтаксис, в котором реализован файл шаблона.

Чтобы в проекте файлы шаблонов, реализованных в JS-синтаксисе, отличались от файлов шаблонов в сокращенном, можно использовать для них разные суффиксы:

 * для сокращенного синтаксиса  — суффикс `.bemhtml`;
 * для JS-синтаксиса  — суффикс `.bemhtml.xjst`.


**Важно** Нельзя использовать в файле шаблона оба синтаксиса одновременно. 


***

**NB** Шаблоны можно автоматически преобразовать из сокращенного в JS-синтаксис. Для их компиляции служит модуль [bemhtml-compat](https://github.com/bem/bemhtml-compat). Но код, полученный в результате компиляции, сложен для восприятия. Это затрудняет его дальнейшую разработку и поддержку. 

***


<a id="sintax"></a>
##JavaScript-cинтаксис BEMHTML шаблонов

Чтобы упростить создание BEMHTML-шаблонов с JavaScript-синтаксисом, используется модуль [bem-xjst](https://github.com/bem/bem-xjst).

BEM-XJST это набор БЭМ-ориентированных хелперов, расширяющий стандартный XJST-синтаксис. Для BEMHTML-шаблонов в JS-синтаксисе он позволяет использовать:

  * хелперы для записи подпредикатов, относящихся к предметной области БЭМ; 
  * хелперы для определение подпредиката по моде;
  * хелперы для применения XJST-конструкций `apply` и `applyNext` по произвольной моде;
  * конструкцию [applyCtx](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#applyctx).


BEM-XJST является надмножеством языка шаблонов XJST, который, в свою очередь, является надмножеством JavaScript.

BEM-XJST использует канонический XJST-синтаксис, расширенный набором правил, относящихся к предметной области БЭМ. Такая реализация позволяет в dev-среде  выполнять BEMHTML шаблоны, написанные в JS-синтаксисе, без предварительной компиляции.


**NB** Методы `apply` и `applyNext` в BEM-XJST могут принимать строковый литерал или выражение, приводимое к строке, вместо выражений присвоения. Это означает «выставить указанную строку в качестве моды».
Например, выражение ``apply('content')`` эквивалентно выражению ``apply(this._mode = 'content')``.

***

<a name="template"></a>

#### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен тогда и только тогда, когда истинны все подпредикаты. 


В сокращенном синтаксисе предикат и тело разделяются двоеточием, а подпредикаты — запятыми:

```
подпредикат1, подпредикат2, подпредикат3: тело
```

В JS-синтаксисе для работы с шаблоном вводится ключевое слово `match`. 

Ключевое слово `match` — это метод-хелпер, принимающий аргументом перечень подпредикатов. Возвращаемым значением метода является функция от одного аргумента — тела шаблона.

```
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Например:

```js
match(this.block === 'link', this._mode === 'tag', this.ctx.url)('a');
```

Так же, набор подпредикатов может быть записан каскадом:

```js
match(this.block === 'link').match(this._mode === 'tag').match(this.ctx.url)('a');
```

Приведенные выше примеры тождественны и соответствуют следующей записи в сокращенном синтаксисе:

```
block link, tag, this.ctx.url: 'a'
```

----
**NB** Если для данного контекста определено более одного шаблона, то выполняется **последний** в порядке перечисления в BEMHTML-файле.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.
***


<a name="podpredicate"></a>

#### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEMHTML предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие.


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для БЭМ-сущностей в предикатах используются следующие ключевые слова:

БЭМ-сущность — **Блок**.
***

Ключевое слово — `block`

Аргументы:
* имя блока

Пример в сокращенном синтаксисе:
```
block b-menu, block 'b-menu', block 'b' + '-menu'
```

Пример в JS-синтаксисе:
```js
block('b-menu'), block("b-menu"), block('b' + '-menu')
```
***


БЭМ-сущность —**Элемент**.
***

Ключевое слово — `elem`


Аргументы:
* имя элемента

Пример в сокращенном синтаксисе:
```
block b-menu, elem item
```

Пример в JS-синтаксисе:
```js
block('b-menu')(elem('item')) или block('b-menu').elem('item')
```
***


БЭМ-сущность —**Модификатор блока**.
***

Ключевое слово — `mod`

Аргументы:
* имя модификатора блока;
* значение модификатора блока.

Пример в сокращенном синтаксисе:
```
block b-head-logo, mod size big
```

Пример в JS-синтаксисе:
```js
block('b-head-logo')(mod('size', 'big')) или block('b-head-logo').mod('size', 'big')
```
***


БЭМ-сущность —**Модификатор элемента**.
***

Ключевое слово —  `mods`

Аргументы:
* имя модификатора элемента;
* значение модификатора элемента.

Пример в сокращенном синтаксисе:
```
block b-head-logo, elem text, elem size big
```

Пример в JS-синтаксисе:
```js
block('b-head-logo')(elem('text')(mods('size', 'big')))
```

***


Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть
указано любое JS-выражение, которое будет приведено к строке.


В JS-синтаксисе ключевые слова, относящиеся к БЭМ-предметной области, используются для сокращенной записи подпредикатов. 
В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.

Следующие предикаты тождественны:

```
match(this.block === 'foo').match(this.elem === 'bar')
```

```
block('foo').elem('bar')
```


Чтобы шаблоны выполнялись без компиляции было добавлено ключевое слово `elemMatch`. Оно используется при записи произвольного подпредиката для элемента:

```js
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```

Чтобы избежать срабатывания парсера на элементы, в процессе обработки шаблонов блоков, производится добавление кастомного подпредиката `!this.elem` к шаблонам, где нет подпредикатов, описывающих элементы. 


***


<a name="moda"></a>

##### Мода

В качестве подпредиката может выступать название одной из [стандартных мод](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#standardmoda). Это означает, что данный
предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:

* `default`
* `tag`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `attrs`
* `content`

В JS-синтаксисе, чтобы определить подпредикат по одной из стандартных мод можно воспользоваться хелпером, соответствующим ключевому слову. 

Например, выражение ``tag()('foo')`` эквивалентно выражению ``match(this._mode === 'tag')('foo')``.


В сокращенном синтаксисе любой подпредикат, состоящий только из идентификатора (`[a-zA-Z0-9-]+`), интерпретируется как название
нестандартной моды. Например, подпредикат `my-mode` эквивалентен подпредикату `` this._mode === 'my-mode' ``.


В JS-синтаксисе, для определения подпредиката по нестандартной моде вводится ключевое слово `mode`. Это метод-хелпер действующий аналогично конструкции `match`. Метод принимает аргументом строку, с названием нестандартной моды и возвращает функцию от одного аргумента — тела шаблона. Таким образом, запись `mode('my-mode')` эквивалентна записи `` this._mode === 'my-mode' ``.



***


##### Произвольное условие
<a name="random_condition"></a>

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.


В JS-синтаксисе для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```js
match(this.ctx.url)(
        tag()('a'), // в момент выолнения моды tag передает аргументом строку с тэгом  'a' 
        attrs()({ href: this.ctx.url }) //в момент выолнения моды attrs передает аргументом хеш с атрибутами
    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, когда полю `url` в контексте присвоено значение. В этом случае будет выполнено тело шаблона.


***

<a name="body"></a>

#### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного HTML.
В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:
	* сокращенный синтаксис:
```
предикат: JS-выражение
```
	
	* JS-синтаксис:
```
match(предикат)(JS-выражение)
```

* Блок JavaScript-кода, заключенный в фигурные скобки:
	* сокращенный синтаксис:
```
предикат: { JS-блок }
```
	
	* JS-синтаксис:
```
match(предикат)({ JS-блок })
```


* Хеш, состоящий из пар `ключ:значение`, разделенных запятыми и заключенный в фигурные скобки:
	* сокращенный синтаксис:
```
предикат: ({name: value})
```

	* JS-синтаксис:
```
match(предикат)({имя: значение})
```

***


В JS-синтаксисе тело шаблона передается аргументом в функцию, возвращаемую методом `match`, и хелперами для БЭМ-сущности или моды.

Синтаксис:

```
стандартная-мода()(тело)

mode('нестандартная-мода')(тело)

БЭМ-сущность('имя-сущности')(тело)

match(произвольный предикат)(тело)
```

***



#### Вложенность шаблонов

Если несколько шаблонов имеют общие подпредикаты, они могут быть записаны в виде вложенной структуры для сокращения количества повторов в коде.

 Уровень вложенности подпредикатов не ограничен.

В сокращенном синтаксисе для обозначения вложенности используются фигурные скобки. Фигурные скобки ставятся после общей части предикатов,
в них заключается блок кода, содержащий различающиеся части предикатов и соответствующие им тела шаблонов.

```
подпредикат1 {
  подпредикат2: тело1
  подпредикат3: тело2
}
```

Данная запись эквивалентна следующей:

```
подпредикат 1, подпредикат 2: тело1
подпредикат 1, подпредикат 3: тело2
```

В JS-синтаксисе вложенные подпредикаты записываются в тело шаблона.  Иначе говоря, подпредикаты передаются аргументом функции, возвращаемой методом `match` и хелперами для БЭМ-сущностей или мод.

Например шаблон в сокращенном синтаксисе:

```js
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

может быть записан в виде:

```
match(this.block === 'link')(
match(this._mode === 'tag')('a'),
match(this._mode === 'attrs')({ href: this.ctx.url })
)
```


Это эквивалентно следующей записи:

```js
match(this.block === 'link').match(this._mode === 'tag')('a');
match(this.block === 'link').match(this._mode === 'attrs')({ href: this.ctx.url });
```


***

Чтобы сделать запись более лаконичной могут использоваться хелперы для БЭМ-сущностей и названий стандартных мод.


Предыдущий пример может быть записан в виде:

```js
block('link')(
    tag()('a'),
    attrs()({ href: this.ctx.url })
)
```


***

В BEMHTML-шаблонах можно выкладывать на один уровень тело шаблона и подшаблоны.

В сокращенном синтаксисе для реализации такой возможности использовалось ключевое слово `true`:

```
this.ctx.url {
    true: 'a'
    mods not-link yes: 'span'
}
```

В JS-синтаксисе тело шаблона передается функции, возвращаемой хелпером, первым аргументом, а подшаблоны следующими:

```js
match(this.ctx.url)(
    'a',
    mods('not-link', 'yes')('span')
)
```


Глубина вложенности подшаблонов не ограничена:

```js
block('link')(
    tag()('span'),
    match(this.ctx.url)(
        tag()('a'),
        attrs()({ href: this.ctx.url })
    )
)
```

**NB** Не рекомендуется использовать для записи вложенных подшаблонов тернарный оператор или условные операторы JavaScript. Такая запись не будет оптимизированна в продакшен среде исполнения.


<a id="runmode"></a>
##Среда исполнения шаблонов

Шаблонизатор BEMHTML может работать в двух режимах, в зависимости от настроек **среды исполнения**. Шаблонизатор поддерживает две среды исполнения: 

* cреда разработки (dev-среда);
* продакшен среда.


Основная разница заключается в том, что в продакшен среде производятся XJST-преобразования шаблонов, в результате которых получается оптимизированный JavaScript. Это увеличивает время сборки проекта за счет компиляции шаблонов, но, в дальнейшем, повышает скорость их выполнения.

Среда исполнения выбирается шаблонизатором на основании значения переменной окружения `process.env.BEMHTML_ENV`. При ее значении равном `'development'` используется среда разработки.

Настройки среды исполнения указывают, в которой из двух возможных сред будут исполняться шаблоны.

Настройки среды исполнения влияют на ход выполнения шаблонов, реализованных как в сокращенном, так и в JS- синтаксисах.


Подробнее о настройках среды разработки читайте [здесь](#).


<a id="run"></a>
##Обработка BEMHTML-шаблонов

Шаблонизатор обрабатывает BEMHTML-шаблоны в два этапа:

* компиляция;
* выполнение.


<a id="runpre"></a>
###Компиляция шаблонов

Шаблонизатор компилирует шаблоны по разному в зависимости от настроек среды исполнения и синтаксиса шаблонов.


<a id="runclassic"></a>
####сокращенный синтаксис

Вне зависимости от настроек среды исполнения производятся следующие действия: 

* все BEMHTML шаблоны, участвующие в сборке, собираются в файл бандла; 
* шаблоны из бандла преобразуются в XJST-синтаксис;


**В продакшен среде исполнния**: 
	
* выполняются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript;


<a id="runjs"></a>
####JavaScript-синтаксис

Вне зависимости от настроек среды исполнения производятся следующие действия: 

* все BEMHTML шаблоны, участвующие в сборке, собираются в файл бандла; 

**В продакшен среде исполнния**: 

* выполняются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript;



<a id="runmain"></a>
###Выполнение шаблонов

Код JavaScript, полученный на этапе компиляции шаблонов, выполняется. Ход выполнения одинаков для всех синтаксисов и настроек среды исполнения:

* шаблонизатор принимает на вход БЭМ-дерево в формате [BEMJSON](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#bemjson);
* последовательно обходит узлы входного БЭМ-дерева;
	* в процессе обхода входного BEMJSON-дерева строится структура данных — [контекст](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#context);
* выполняется цикл генерации выходного HTML-элемента для каждой БЭМ-сущности;
	* рекурсивно выполняется цикл генерации выходных HTML-элементов для вложенных БЭМ-сущностей; 
	* поэлементно выполняется запись в буфер HTML-результата.


***


TODO:

###Таблица соответствия стандартных операций шаблонизатора в разных синтаксисах


| Операция | сокращенный синтаксис | JS-синтаксис |
| ------------- |-------------|------------- |-------------|------------- |-------------|
| Совпадение с БЭМ-сущностью | БЭМ-сущность имя-сущности | БЭМ-сущность('имя-сущности') |
| Совпадение со стандартной модой  | название-стандартной-моды  | название-стандартной-моды() |
| Совпадение с нестандартной модой   |  название-нестандартной-моды | mode('название-нестандартной-моды')  |
| Совпадение с произвольным условием | выражение === значение  | match(произвольный-подпредикат)  |

