#JS-синтаксис BEMHTML. Руководство по миграции.

<a id="intro"></a>
##Введение

Документ предназначен для веб-разработчиков и HTML-верстальщиков, использующих [БЭМ-методологию](http://ru.bem.info/method/) и [шаблонизатор BEMHTML](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/).

В документе описаны:	

* [совместимость](#compat) BEMHTML шаблонов, реализованных в разном синтаксисе;
* настройки [среды исполнения шаблонов](#runmode);
* схема [обработки BEMHTML-шаблонов](#run);
* реализация в [JavaScript-синтаксисе](#sintax) стандартных операций шаблонизатора BEMHTML;
* [алгоритм преобразования](#steps) шаблонов из сокращенного в JS-синтаксис.

В документе не описаны настройка среды разработки и процедуры компиляции шаблонов, особенности шаблонизатора BEMHTML, формат входных данных [BEMJSON](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#bemjson).


<a id="general"></a>
##Общие сведения

С версии v1.0.0 в библиотеку [bem-core](https://github.com/bem/bem-core/tree/v1), была добавлена возможность исполнять BEMHTML-шаблоны, написанные в JavaScript-синтаксисе.

В библиотеке поддерживается как **сокращенный**, так и JS- синтаксисы. С момента выпуска библиотеки bem-core сокращенный синтаксис шаблонов считается устаревшим. 

JavaScript-синтаксис BEMHTML-шаблонов имеет следующие преимущества:

* поддержка синтаксиса различными средами разработки и инструментами (т.к. код — обычный JavaScript):
	* подсветка кода;
	* JSHint, JSLint, etc. 
* может выполняться тот же код, который пишется (в [dev-среде исполнения](#runmode)). Это упрощает поиск ошибок и отладку;
* более высокая скорость [компиляции](#run) (особенно в dev-среде исполнени).

Шаблонизатор BEMHTML при использовании с шаблонами, созданными в JS-синтаксисе, сохраняет все ключевые особенности.

***

<a id="install"></a>
##Начало работы

Возможность исполнения BEMHTML-шаблонов с JS-синтаксисом доступна  во всех компонентах БЭМ-платформы, использующих bem-core.

Для перехода на JS-синтаксис можно:

* воспользоваться версией project-stub, использующей bem-core (ветка [bem-core](https://github.com/bem/project-stub/tree/bem-core));
* самостоятельно установить необходимые пакеты — [bem-xjst](https://github.com/bem/bem-xjst), [bemhtml-compat](https://github.com/bem/bemhtml-compat), модуль технологии пакета bem-tools [BEMHTML API v2](https://github.com/bem/bem-core/blob/v1/.bem/techs/bemhtml.js).

Модуль технологии BEMHTML, поддерживающий JS-синтаксис, реализован с [API v2 технологии](http://ru.bem.info/tools/bem/bem-tools/tech-modules/#%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-api-v2-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8) bem-tools. Для использования его в проекте требуется пакет bem-tools с версией не ниже 0.6.4.

***


<a id="compat"></a>
##Совместимость шаблонов

BEMHTML-шаблоны, реализованные в разном синтаксисе, могут использоваться в одном проекте.

В процессе выполнения, шаблонизатор приводит шаблоны, созданные в сокращенный синтаксисе к JS-синтаксису (используя модуль [bemhtml-compat](https://github.com/bem/bemhtml-compat)). Подробнее об этом читайте в разделе [Выполнение шаблонов](#run).

В ходе парсинга шаблонизатор автоматически определяет синтаксис, в котором реализован файл шаблона.

Чтобы в проекте файлы шаблонов, реализованных в JS-синтаксисе, отличались от файлов шаблонов в сокращенном, можно использовать для них разные суффиксы:

 * для сокращенного синтаксиса  — суффикс `.bemhtml`;
 * для JS-синтаксиса  — суффикс `.bemhtml.xjst`.


**Важно** Нельзя использовать в файле шаблона оба синтаксиса одновременно. 


***


<a id="sintax"></a>
##JavaScript-cинтаксис BEMHTML шаблонов

Чтобы упростить создание BEMHTML-шаблонов с JavaScript-синтаксисом, используется модуль [bem-xjst](https://github.com/bem/bem-xjst).

BEM-XJST это набор БЭМ-ориентированных хелперов, расширяющий стандартный XJST-синтаксис. Для BEMHTML-шаблонов в JS-синтаксисе он позволяет использовать:

  * хелперы для записи подпредикатов, относящихся к предметной области БЭМ; 
  * хелперы для определение подпредиката по моде;
  * хелперы для применения XJST-конструкций `apply` и `applyNext` по произвольной моде;
  * конструкцию [applyCtx](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#applyctx).


BEM-XJST является надмножеством языка шаблонов XJST, который, в свою очередь, является надмножеством JavaScript.

BEM-XJST использует канонический XJST-синтаксис, расширенный набором правил, относящихся к предметной области БЭМ. Такая реализация позволяет в dev-среде  выполнять BEMHTML шаблоны, написанные в JS-синтаксисе, без предварительной компиляции.


**NB** Методы `apply` и `applyNext` в BEM-XJST могут принимать строковый литерал или выражение, приводимое к строке, вместо выражений присвоения. Это означает «выставить указанную строку в качестве моды».
Например, выражение ``apply('content')`` эквивалентно выражению ``apply({ _mode: 'content' })``.

***

<a name="template"></a>

#### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен тогда и только тогда, когда истинны все подпредикаты. 


В сокращенном синтаксисе предикат и тело разделяются двоеточием, а подпредикаты — запятыми:

```
подпредикат1, подпредикат2, подпредикат3: тело
```

В JS-синтаксисе для работы с шаблоном вводится ключевое слово `match`. 

Ключевое слово `match` — это метод-хелпер, принимающий аргументом перечень подпредикатов. Возвращаемым значением метода является функция, принимающая аргументом тело шаблона.

```
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Например:

```js
match(this.block === 'link', this._mode === 'tag', this.ctx.url)('a');
```

Так же, набор подпредикатов может быть записан цепочкой:

```js
match(this.block === 'link').match(this._mode === 'tag').match(this.ctx.url)('a');
```

Приведенные выше примеры тождественны и соответствуют следующей записи в сокращенном синтаксисе:

```
block link, tag, this.ctx.url: 'a'
```

----
**NB** Если для данного контекста определено более одного шаблона, то **последний** в порядке перечисления в BEMHTML-файле, имеет больший приоритет.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.
***


<a name="podpredicate"></a>

#### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEMHTML предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие.


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для БЭМ-сущностей в предикатах используются следующие ключевые слова:

БЭМ-сущность — **Блок**.
***

Ключевое слово — `block`

Аргументы:
* имя блока

Пример в сокращенном синтаксисе:
`block b-menu` или `block 'b-menu'` или `block 'b' + '-menu'`


Пример в JS-синтаксисе:
`block('b-menu')` или `block('b' + '-menu')`


***


БЭМ-сущность —**Элемент**.
***

Ключевое слово — `elem`


Аргументы:
* имя элемента

Пример в сокращенном синтаксисе:
```
block b-menu, elem item
```

Пример в JS-синтаксисе:
```js
block('b-menu').elem('item')
```
***


БЭМ-сущность —**Модификатор блока**.
***

Ключевое слово — `mod`

Аргументы:
* имя модификатора блока;
* значение модификатора блока.

Пример в сокращенном синтаксисе:
```
block b-head-logo, mod size big
```

Пример в JS-синтаксисе:
```js
block('b-head-logo').mod('size', 'big')
```
***


БЭМ-сущность —**Модификатор элемента**.
***
Ключевое слово в сокращенном синтаксисе —`elemMod`
Ключевое слово в JS-синтаксисе —  `mods`

Аргументы:
* имя модификатора элемента;
* значение модификатора элемента.

Пример в сокращенном синтаксисе:
```
block b-head-logo, elem text, elemMod size big
```

Пример в JS-синтаксисе:
```js
block('b-head-logo')(elem('text').mods('size', 'big'))
```

***


**NB** Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть
указано любое JS-выражение, которое будет приведено к строке. Например, запись block('b-head-logo') тождественна записи `block('b-' + 'head' + '-logo')`.



В JS-синтаксисе ключевые слова, относящиеся к БЭМ-предметной области, используются для сокращенной записи подпредикатов. 
В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.

Следующие предикаты тождественны:

```
match(this.block === 'foo').match(this.elem === 'bar')
```

```
block('foo').elem('bar')
```


Чтобы шаблоны выполнялись без компиляции было добавлено ключевое слово `elemMatch`. Оно используется при записи произвольного подпредиката для элемента:

```js
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```
Дело в том, что в процессе обработки к шаблонам, где нет подпредикатов, описывающих элементы автоматически добавляется кастомный подпредикат `!this.elem`. Делается это, чтобы во время выполнения шаблонов блоков избежать срабатывания шаблонизатора на элементы.

Как следствие, предыдущий пример записанный без  `elemMatch` работать не будет:

```js
block('my-block')
    .match(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```

Ведь в процессе обработки к нему будет добавлен подпредикат  `!this.elem`.


***


<a name="moda"></a>

##### Мода

В качестве подпредиката может выступать название одной из [стандартных мод](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#standardmoda). Это означает, что данный
предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:

* `default`
* `tag`
* `attrs`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `content`

В JS-синтаксисе, чтобы определить подпредикат по одной из стандартных мод можно воспользоваться хелпером, соответствующим ключевому слову. 

Например, выражение ``tag()('span')`` эквивалентно выражению ``match(this._mode === 'tag')('span')``.


В сокращенном синтаксисе любой подпредикат, состоящий только из идентификатора (`[a-zA-Z0-9-]+`), интерпретируется как название
нестандартной моды. Например, подпредикат `my-mode` эквивалентен подпредикату `` this._mode === 'my-mode' ``.


В JS-синтаксисе, для определения подпредиката по нестандартной моде вводится ключевое слово `mode`. Это метод-хелпер действующий аналогично конструкции `match`. Метод принимает аргументом строку, с названием нестандартной моды и возвращает функцию от одного аргумента — тела шаблона. Таким образом, запись `mode('my-mode')` эквивалентна записи `` this._mode === 'my-mode' ``.


***


##### Произвольное условие
<a name="random_condition"></a>

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.


В JS-синтаксисе для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```js
match(this.ctx.url)(
        tag()('a'), // в момент выолнения моды tag передает аргументом строку с тэгом  'a' 
        attrs()({ href: this.ctx.url }) // в момент выолнения моды attrs передает аргументом хеш с атрибутами
    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, когда полю `url` в контексте присвоено значение. В этом случае будет выполнено тело шаблона.


***

<a name="body"></a>

#### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного HTML.
В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:
	* сокращенный синтаксис:
```
предикат: JS-выражение
```
	
	* JS-синтаксис:
```
match(предикат)(JS-выражение)
```

* Блок JavaScript-кода:
	* сокращенный синтаксис:
```
предикат: { JS-код }
```
	
	* JS-синтаксис:
```
match(предикат)(function() { JS-код })
```

***


В JS-синтаксисе тело шаблона передается аргументом в функцию, возвращаемую методом `match`, и хелперами для БЭМ-сущности или моды.

Синтаксис:

```
стандартная-мода()(тело)

mode('нестандартная-мода')(тело)

БЭМ-сущность('имя-сущности')(тело)

match(произвольный предикат)(тело)
```


**NB**  Важно помнить, что тело шаблона передается в функцию, возвращаемую методом-хелпером, а не в сам хелпер. 

Неправильно:
```
block('b1').tag('span') 
```

Правильно:

```
block('b1').tag()('span')
```

***



#### Вложенность шаблонов

Если несколько шаблонов имеют общие подпредикаты, они могут быть записаны в виде вложенной структуры для сокращения количества повторов в коде.

 Уровень вложенности подпредикатов не ограничен.

В сокращенном синтаксисе для обозначения вложенности используются фигурные скобки. Фигурные скобки ставятся после общей части предикатов,
в них заключается блок кода, содержащий различающиеся части предикатов и соответствующие им тела шаблонов.

```
подпредикат1 {
  подпредикат2: тело1
  подпредикат3: тело2
}
```

Данная запись эквивалентна следующей:

```
подпредикат 1, подпредикат 2: тело1
подпредикат 1, подпредикат 3: тело2
```

В JS-синтаксисе вложенные подпредикаты записываются в тело шаблона.  Иначе говоря, подпредикаты передаются аргументом функции, возвращаемой методом `match` и хелперами для БЭМ-сущностей или мод.

Например шаблон в сокращенном синтаксисе:

```js
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

может быть записан в виде:

```
match(this.block === 'link')(
   match(this._mode === 'tag')('a'),
   match(this._mode === 'attrs')({ href: this.ctx.url })
)
```


Это эквивалентно следующей записи:

```js
match(this.block === 'link').match(this._mode === 'tag')('a');
match(this.block === 'link').match(this._mode === 'attrs')({ href: this.ctx.url });
```


***

Чтобы сделать запись более лаконичной могут использоваться хелперы для БЭМ-сущностей и названий стандартных мод.


Предыдущий пример может быть записан в виде:

```js
block('link')(
    tag()('a'),
    attrs()({ href: this.ctx.url })
)
```


***

В BEMHTML-шаблонах можно выкладывать на один уровень тело шаблона и подшаблоны.

В сокращенном синтаксисе для реализации такой возможности использовалось ключевое слово `true`:

```
block link, tag, this.ctx.url {
    true: 'a'
    mods not-link yes: 'span'
}
```

В JS-синтаксисе тело шаблона передается функции, возвращаемой хелпером, первым аргументом, а подшаблоны следующими:

```js
block('link').tag().match(this.ctx.url)(
    'a',
    mods('not-link', 'yes')('span')
)
```

***

Глубина вложенности подшаблонов не ограничена:

```js
block('link')(
    tag()('span'),
    match(this.ctx.url)(
        tag()('a'),
        attrs()({ href: this.ctx.url })
    )
)
```

**NB** Не рекомендуется использовать для записи вложенных подшаблонов тернарный оператор или условные операторы JavaScript. Такая запись не будет оптимизированна в продакшен среде исполнения.


<a id="runmode"></a>
##Среда исполнения шаблонов

Шаблонизатор BEMHTML может работать в двух режимах, в зависимости от настроек **среды исполнения**. Шаблонизатор поддерживает две среды исполнения: 

* cреда разработки (dev-среда);
* продакшен среда.


Основная разница заключается в том, что в продакшен среде производятся XJST-преобразования шаблонов, в результате которых получается оптимизированный JavaScript. Это увеличивает время сборки проекта за счет компиляции шаблонов, но, в дальнейшем, повышает скорость их выполнения.

Среда исполнения выбирается шаблонизатором на основании значения переменной окружения `process.env.BEMHTML_ENV`. При ее значении равном `'development'` используется среда разработки.

Настройки среды исполнения указывают, в которой из двух возможных сред будут исполняться шаблоны.

Настройки среды исполнения влияют на ход выполнения шаблонов, реализованных как в сокращенном, так и в JS- синтаксисах.


Подробнее о настройках среды разработки читайте [здесь](#).


<a id="run"></a>
##Обработка BEMHTML-шаблонов

Шаблонизатор обрабатывает BEMHTML-шаблоны в два этапа:

* компиляция;
* выполнение.


<a id="runpre"></a>
###Компиляция шаблонов

Шаблонизатор компилирует шаблоны по разному в зависимости от настроек среды исполнения и синтаксиса шаблонов.


<a id="runclassic"></a>
####сокращенный синтаксис

Вне зависимости от настроек среды исполнения производятся следующие действия: 

* все BEMHTML шаблоны, участвующие в сборке, собираются в файл бандла; 
* шаблоны из бандла преобразуются в XJST-синтаксис;


**В продакшен среде исполнния**: 
	
* выполняются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript;


<a id="runjs"></a>
####JavaScript-синтаксис

Вне зависимости от настроек среды исполнения производятся следующие действия: 

* все BEMHTML шаблоны, участвующие в сборке, собираются в файл бандла; 

**В продакшен среде исполнния**: 

* выполняются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript;



<a id="runmain"></a>
###Выполнение шаблонов

Код JavaScript, полученный на этапе компиляции шаблонов, выполняется. Ход выполнения одинаков для всех синтаксисов и настроек среды исполнения:

* шаблонизатор принимает на вход БЭМ-дерево в формате [BEMJSON](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#bemjson);
* последовательно обходит узлы входного БЭМ-дерева;
	* в процессе обхода входного BEMJSON-дерева строится структура данных — [контекст](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#context);
* выполняется цикл генерации выходного HTML-элемента для каждой БЭМ-сущности;
	* рекурсивно выполняется цикл генерации выходных HTML-элементов для вложенных БЭМ-сущностей; 
	* поэлементно выполняется запись в буфер фрагментов HTML-результата.


***

<a id="table"></a>
###Таблица соответствия стандартных операций шаблонизатора в разных синтаксисах


| Операция | Cокращенный синтаксис | JS-синтаксис |
| ------------- |-------------|------------- |-------------|------------- |-------------|
| Совпадение с БЭМ-сущностью | БЭМ-сущность идентификатор-сущности : тело | БЭМ-сущность('идентификатор-сущности')(тело) |
| Совпадение со стандартной модой  | название-стандартной-моды : тело  | название-стандартной-моды()(тело) |
| Совпадение с нестандартной модой   |  название-нестандартной-моды : тело | mode('название-нестандартной-моды')(тело)  |
| Совпадение с произвольным условием | выражение === значение : тело | match(произвольный-подпредикат)(тело)  |



<a id="steps"></a>
###Алгоритм ручного преобразования шаблонов из сокращенного в JS-синтаксис
Есть набор простых правил, позволяющих шаг за шагом преобразовать шаблоны из сокращенного в JS-синтаксис. 


| Номер шага | Описание | Патерн |
| ------------- |-------------|------------- |-------------|------------- |-------------|
|  1.  | Взять в кавычки имена БЭМ-сущностей | `b1 -> 'b1'` |
|  2. | Заменить сокращения для БЭМ-сущностей на хелперы | `block 'b1' -> block('b1')` |
|  3. | Заменить все запятые на точки | ` , -> .` |
|  4. | Заменить названия стандартных мод на хелперы | `tag -> tag()` |
|  5. | Заменить двоеточие перед телом шаблонов на открывающую скобку и добавить после тела закрывающую | ` : ...  -> (...)` |
|  6. | Обернуть произвольные подпредикаты в хелпер `match` | `this.ctx.foo !== undefined -> match(this.ctx.foo !== undefined)` |
|  7. | Обернуть оставшиеся подпредикаты в хелпер `mode` и взять в кавычки | `some-mode -> mode('some-mode')` |
|  8. | Заменить фигурные скобки, указывающие вложенность, обычными скобками | `block('b1'){elem('e1')} -> block('b1')(elem('e1'))` |


Разберем на примере, как производится пошаговое преобразование.

**Исходный код:**

```js
block b-link, elem e1 {
  tag: 'span'
  this.ctx.url {
    tag: 'a'
    attrs: { href: this.ctx.url }
    reset: 
         attrs: { href: undefined }
  }
}
```

**Шаг 1. Берем в кавычки имена БЭМ-сущностей:**

```js
block 'b-link', elem 'e1' {
  tag: 'span'
  this.ctx.url {
    tag: 'a'
    attrs: { href: this.ctx.url }    
    reset: 
         attrs: { href: undefined }
  }
}
```

**Шаг 2. Заменяем сокращения для БЭМ-сущностей на хелперы:**

```js
block('b-link'), elem('e1') {
  tag: 'span'
  this.ctx.url {
    tag: 'a'
    attrs: { href: this.ctx.url }    
    reset: 
         attrs: { href: undefined }
  }
}
```

**Шаг 3. Заменяем все запятые на точки:**

```js
block('b-link'). elem('e1') {
  tag: 'span'
  this.ctx.url {
    tag: 'a'
    attrs: { href: this.ctx.url }
    reset: 
         attrs: { href: undefined }
  }
}
```

**Шаг 4. Заменяем названия стандартных мод на хелперы:**

```js
block('b-link'). elem('e1') {
  tag(): 'span'
  this.ctx.url {
    tag(): 'a'
    attrs(): { href: this.ctx.url }
    reset: 
         attrs(): { href: undefined }
  }
}
```

**Шаг 5. Заменяем двоеточие перед телом шаблонов на открывающую скобку и добавляем после тела закрывающую:**

```js
block('b-link'). elem('e1') {
  tag()('span')
  this.ctx.url {
    tag()('a')
    attrs()({ href: this.ctx.url })
    reset( 
         attrs()( { href: undefined }))
  }
}
```

**Шаг 6. Оборачиваем произвольные подпредикаты в хелпер `match`:**

```js
block('b-link'). elem('e1') {
  tag()('span')
  match(this.ctx.url) {
    tag()('a')
    attrs()({ href: this.ctx.url })
    reset( 
         attrs()({ href: undefined }))
  }
}
```

**Шаг 7.  Оборачиваем оставшиеся подпредикаты в хелпер `mode` и берем в кавычки:**

```js
block('b-link'). elem('e1') {
  tag()('span')
  match(this.ctx.url) {
    tag()('a')
    attrs()({ href: this.ctx.url })
    mode('reset')( 
         attrs()({ href: undefined }))
  }
}
```

**Шаг 8. Заменяем фигурные скобки, указывающие вложенность, обычными скобками:**

```js
block('b-link'). elem('e1') (
  tag()('span')
  match(this.ctx.url) (
    tag()('a')
    attrs()({ href: this.ctx.url })
    mode('reset')( 
         attrs()({ href: undefined }))
  )
)
```

Чай готов!