#JS-синтаксис в BEMHTML

##Введение
<a id="intro"></a>

Документ представляет собой руководство разработчика по использованию шаблонизатора BEMHTML с JS-синтаксисом.

В документе описаны:

* особенности использования BEMHTML с JS-синтаксисом;
* совместимость BEMHTML шаблонов, реализованных в разном синтаксисе;
* реализация в JS-синтаксисе стандартных операций шаблонизатора BEMHTML;
* примеры решения типовых задач средствами BEMHTML с использованием JS-синтаксиса.

Целевая аудитория документа — веб-разработчики и HTML-верстальщики, использующие [БЭМ-методологию](http://ru.bem.info/method/).

Предполагается, что читатель знаком с:

* HTML;
* JavaScript;
* CSS;
* БЭМ;
* BEMHTML;
* BEMJSON.

В документе не описаны настройка среды разработки и процедуры компиляции шаблонов, особенности шаблонизатора BEMHTML.

##Общие сведения
<a id="general"></a>

В  библиотеку bem-core, была добавлена поддержка JavaScript-синтаксиса для BEMHTML шаблонов.

Сейчас в библиотеке поддерживается как традиционный так и новый синтаксисы. В дальнейшем при разработке блоков предпочтение будет отдаваться JS-синтаксису.

Главных причин для этого три:
* более высокая скорость работы шаблонизатора. Шаблон выполняется со скоростью конкатенации файлов.
* удобство разработки. Подсветка синтаксиса в различных средах разработки, более удобная отладка, легче поиск ошибок.
* нет необходимости в перекомпиляции при изменении шаблона.

При использовании с JS-синтаксисом шаблонизатор BEMHTML сохраняет такие особенности как:

* привязка к БЭМ-предметной области;
* декларативные шаблоны;
* JavaScript — язык описания и исполнения шаблонов;
* порядок обработки входных данных и генерации HTML;
* входные данные — БЭМ-дерево в формате [BEMJSON](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#bemjson).


###Реализация
<a id="implementation"></a>

Использование JavaScript-синтаксиса при написании BEMHTML шаблонов стало возможно благодаря [BEM-XJST](https://github.com/bem/bem-xjst).

Это набор БЭМ-ориентированных хелперов, расширяющий стандартный XJST-синтаксис. BEM-XJST предоставляет:
  - синтаксический сахар для подпредикатов, относящихся к предметной области БЭМ; 
  - возможность писать вложенные шаблоны;
  - синтаксический сахар для вызова `apply` по какой-то mode (`apply(this._mode = 'foo')`)
  - конструкцию `applyCtx` (сокращенную запись для `applyNext(this.ctx = { some: 'new' })`)

BEM-XJST является надмножеством языка шаблонов XJST, который, в свою очередь, является надмножеством JavaScript.

BEM-XJST использует канонический XJST-синтаксис, расширенный набором правил, относящихся к предметной области БЭМ. Такая реализация позволяет в режиме разработки выполнять BEMHTML шаблоны, написанные в JS-синтаксисе, без предварительной компиляции.

В ходе исполнения все BEMHTML шаблоны проекта, участвующие в сборке, собираются в общий бандл.


###Совместимость
<a id="compat"></a>

В bem-core поддержка совместимости разных синтаксисов реализована в модуле технологии BEMHTML. Для этого используется модуль [BEMHTML-COMPAT](https://github.com/bem/bemhtml-compat), основной функциональностью которого является преобразование BEMHTML шаблонов из традиционного синтаксиса в BEM-XJST.

Необходимость преобразования определяется модулем технологии на основании суффикса файла шаблона:

* для файлов с суффиксом `.bemhtml` запускается процедура преобразования в BEM-XJST синтаксис `compat.transpile()`;
* содержимое файлов с суфииксом `.bemhtml.xjst` помещается в общий рантайм бандл в неизмененном виде (в начале и конце добавляются служебные конструкции).

Такая схема накладывает следующие ограничения:

* файлы BEMHTML шаблонов в блоках должны иметь суффикс, соответствующий синтаксису, в котором они реализованы (для JS-синтаксиса это будет `.bemhtml.xjst`);
* не рекомендуется использовать в файле шаблона оба синтаксиса одновременно. Точнее, в файле шаблона с суффиксом `.bemhtml` могут присутствовать фрагменты кода в JS-синтаксисе, но не наоборот.

**NB** В сборке могут участвовать BEMHTML-файлы блоков, реализованные как в JS-, так и в классическом синтаксисе. Из них будет собран бандл с общим суффиксом `.bemhtml`. При этом, шаблоны в традиционном синтаксисе будут предварительно транслированы в XJST-синтаксис. 


##Подключение
<a id="install"></a>

Поддержка технологии BEM-XJST включена в библиотеку блоков `bem-core v1`. Как следствие, можно пользоваться JS-синтаксисом `BEMHTML` во всех компонентах БЭМ-платформы, использующих `bem-core`.

Для начала работы с шаблонизатором `BEMHTML` в JS-синтаксисе можно:
* воспользоваться версией `project-stub`, использующей `bem-core` (ветка [bem-core](https://github.com/bem/project-stub/tree/bem-core)) ;
* использовать пакет [bem-tools v1.0](https://github.com/bem/bem-tools/tree/release-1.0.0).
* самостоятельно установить необходимые пакеты -- [bem-xjst](https://github.com/bem/bem-xjst), [bemhtml-compat](https://github.com/bem/bemhtml-compat), модуль технологии [BEMHTML API v2](https://github.com/bem/bem-core/blob/v1/.bem/techs/bemhtml.js).


**NB** Модуль технологии `BEMHTML`с поддержкой JS-синтаксиса реализован с [API v2 технологии](http://ru.bem.info/tools/bem/bem-tools/tech-modules/#%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-api-v2-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8) bem-tools. Для использования его в проекте требуется пакет bem-tools с версией не ниже 0.6.4.


###Выполнение шаблонов
<a id="run"></a>

BEMHTML шаблоны созданные в JS-синтаксисе по разному выполняются в режиме разработки и продакшене:

* в режиме разработки, BEMHTML шаблоны собираются в общий рантайм бандл, который затем выполняется;
* в продакшен-режиме после сборки бандла над ним запускаются XJST-преобразования, в результате которых на выходе получается оптимизированный JavaScript. Затем полученный код выполняется.

Режим выполнения определяется на основании значения переменной окружения `process.env.BEMHTML_ENV`. При ее значении равном `'development'` используется режим разработки.

Дальнейший процесс выполнения шаблонизатора такой же, как и для традиционного синтаксиса:
* шаблонизатор принимает на вход БЭМ-дерево в формате BEMJSON;
* последовательно обходит узлы входного БЭМ-дерева;
* в процессе обхода входного BEMJSON-дерева строит структуру данных -- [контекст](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#context)
* выполняет цикл генерации выходного HTML-элемента для каждой БЭМ-сущности;
* рекурсивно выполняет цикл генерации выходных HTML-элементов для вложенных БЭМ-сущностей; 
* поэлементно выполняет запись в буфер HTML-результата (this._buf.push(…)).




##JS-cинтаксис BEMHTML шаблонов
<a id="sintax"></a>

Синтаксис BEMHTML предоставляет лаконичный способ записи соответствия БЭМ-сущностей и генерации HTML-элементов и атрибутов. Помимо этого, в шаблонах могут использоваться любые JavaScript-конструкции.

При использовании BEMHTML шаблонизатора с JS-синтаксисом не предусмотрено технологических ограничений на операции, выполняемые в шаблонах. Фактически, в BEMHTML-коде возможно всё, что возможно в JavaScript.

Все ограничения, обеспечивающие корректность и эффективность выполнения задач шаблонизатора, реализуются на уровне соглашений по написанию шаблонов. 


<a name="template"></a>

#### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен тогда и только тогда, когда истинны все подпредикаты. 

Порядок записи подпредикатов не имеет значения, *порядок проверки подпредикатов не гарантируется*.

В JS-синтаксисе для работы с шаблоном вводится ключевое слово `match`. 

Метод `match` принимает в качестве аргументов перечень подпредикатов. Возвращаемым значением метода является функция, принимающая аргументом тело шаблона.

```(js)
match(this.block === 'link', this._mode === 'tag', this.ctx.url)('a');
```

Так же, набор подпредикатов может быть записан каскадом:

```(js)
match(this.block === 'link').match(this._mode === 'tag').match(this.ctx.url)('a');
```

Приведенные выше примеры тождественны.


Логически программа на BEMHTML представляет собой одноранговый (плоский) **список шаблонов**. Однако если несколько шаблонов имеют **общие подпредикаты**, они могут быть записаны в виде вложенной структуры для сокращения количества повторов в коде.

 Уровень вложенности подпредикатов не ограничен.

```(js)
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

Данная запись эквивалентна следующей:

```(js)
match(this.block === 'link').match(this._mode === 'tag')('a');
match(this.block === 'link').match(this._mode === 'attrs')({ href: this.ctx.url });
```

----
**NB** Если для данного контекста определено более одного шаблона, то выполняется **последний** в порядке перечисления в BEMHTML-файле.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.
***


<a name="podpredicate"></a>

#### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEMHTML предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для этого в предикатах используются следующие ключевые слова:
<table>
<tr>
    <th>Ключевое слово</th>
    <th>Аргументы</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>block</code></td>
    <td>имя блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code> или произвольное js-выражение</td>
    <td><pre><code>block('b-menu'), block ("b-menu"), block('b' + '-menu')</code></pre></td>
</tr>
<tr>
    <td><code>elemMatch</code></td>
    <td>имя элемента</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+</code> или произвольное js-выражение</td>
    <td><pre><code>block('b-menu')(elemMatch('item')), block('b-menu').elemMatch('item')</code></pre></td>
</tr>
<tr>
    <td><code>mod</code></td>
    <td>имя и значение модификатора блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
    <td><pre><code>block('b-head-logo')(mod('size', 'big')),  block('b-head-logo').mod('size', 'big')</code></pre></td>
</tr>
<tr>
   <td><code>mods</code></td>
   <td>имя и значение модификатора элемента</td>
   <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
   <td><pre><code>block('b-head-logo')(elemMatch('text')(mods('size', 'big')))</code></pre></td>
</tr>
</table>

Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть
указано любое JS-выражение, которое будет приведено к строке.

Ключевые слова, относящиеся к БЭМ-предметной области, позволяют сокращенную запись подпредикатов. В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.

Следующие предикаты тождественны:

```
match(this.block === 'foo').match(this.elem === 'bar')
```

```
block('foo').elemMatch('bar')
```


----
**NB** Важно не путать в предикатах модификаторы блока и модификаторы элемента.

 * `block('input').mod('theme', 'black').elemMatch('hint')` задает элемент `hint`, вложенный в блок `input` с **модификатором блока** `theme` в значении `black`.
 * `block('input')(elemMatch('hint').mods('visibility', 'visible'))` задает элемент `hint` с **модификатором элемента** `visibility`   в значении `visible` вложенный в блок `input`.
 * `block('input')(mod('theme', 'black')(elemMatch('hint').mods('visibility', 'visible')))` задает элемент `hint` с **модификатором    элемента** `visibility` в значении `visible` вложенный в блок `input` с **модификатором блока** `theme` в значении   `black`.

Для модификаторов блоков и элементов используются разные ключевые слова, чтобы дать возможность комбинировать в предикатах условия, одновременно включающие упоминания модификаторов блоков и элементов.

Ключевое слово `elemMatch` для записи произвольного подпредиката об элементе было добавлено, чтобы позволить выполнять шаблоны без компиляции:

```(js)
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```

Чтобы избежать срабатывания парсера на элементы, в процессе обработки шаблонов блоков, производится добавление кастомного подпредиката `!this.elem` к шаблонам, где нет подпредикатов, описывающих элементы. 



***

<a name="moda2"></a>

##### Мода

В качестве подпредиката может выступать название одной из [стандартных мод](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#standardmoda). Это означает, что данный
предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:

* `default`
* `tag`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `attrs`
* `content`

Чтобы выставить в качесте подпредиката одну из стандартных мод можно воспользоваться хелпером, соответствующим ключевому слову. 

Например, подпредикат ``tag()('foo')`` эквивалентен подпредикату ``match(this._mode === 'tag')('foo')``.


<a name="random_condition"></a>

##### Произвольное условие

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.

При этом количество **различных** предикатных выражений в подпредикатах шаблонов должно быть минимизировано.
Соблюдение этих условий позволит компилятору XJST производить оптимизации над произвольными условиями шаблонов
наряду с оптимизацией стандартизованных условий (БЭМ-сущности и моды).

Для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```(js)
match(this.ctx.url)(
        tag()('a'), //выставляет текущей моду tag и передает 'a' аргументом
        attrs()({ href: this.ctx.url }) //выставляет текущей моду attrs и передает хеш аргументом 

    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, когда полю `url` в контексте присвоено значение. В этом случае будет выполнено тело шаблона.


***

<a name="body"></a>

#### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного HTML.
В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:

  ```
match(предикат)(JS-выражение)
  ```

* Блок JavaScript-кода, заключенный в фигурные скобки:

  ```
match(предикат)({ JS-блок })
  ```


* Хеш, состоящий из пар ключ:значение, разделенных запятыми и заключенный в фигурные скобки:


```
match(предикат)({имя: значение})
```

***

В рамках тела шаблона можно выполнить следующие действия:

* Вычислить и вернуть значение.
  Если в текущей моде ожидается значение определенного типа, значение, возращаемое при вычислении тела шаблона, будет  приведено к этому типу и использовано. Если шаблон не возвращает никакого значения, будет использовано значение
  `undefined`.
* Вывести данные непосредственно в HTML-результат.
  Для этого в теле шаблона следует выполнить запись в буфер HTML-результата (`this._buf.push(…)`).
* Производить произвольные операции.

Тело шаблона передается аргументом в функцию, возвращаемую методом `match` или хелперами для БЭМ-сущности или моды.

Синтаксис:

```
название-моды()(тело)

БЭМ-сущность()(тело)

match(произвольный предикат)(тело)
```

<a id="xjst"></a>

#### Конструкции XJST

Так как язык BEMHTML является расширением языка [XJST](https://github.com/veged/xjst), в BEMHTML-шаблонах возможно использовать синтаксические
конструкции XJST для модификации контекста и явного вызова процедуры выбора и выполнения шаблонов в измененном контексте.

Подробнее об использовании конструкций XJST в BEMHTML-шаблонах читайте [здесь](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#xjst).

<a id="inner"></a>

#### Вложенность шаблонов
Шаблонизатор BEMHTML не вводит ограничений на вложенность шаблонов. При этом могут использоваться сокращения, относящиеся к БЭМ-сущнастям и названиям мод.

Например следующий шаблон:

```(js)
this.block === 'link' {
    this._mode === 'tag': 'a'
    this._mode === 'attrs': { href: this.ctx.url }
}
```

может быть записан в виде:

```(js)
block('link')(
    tag()('a'),
    attrs()({ href: this.ctx.url })
)
```

Кроме того, использование JS-синтаксиса позволяет в BEMHTML шаблонах выкладывать на один уровень тело шаблона и подшаблоны.

```(js)
match(this.ctx.url)(
    'a',
    mods('not-link', 'yes')('span')
)
```

В традиционном синтаксисе для реализации такой возможности использовалось ключевое слово `true`:

```
this.ctx.url {
    true: 'a'
    mods not-link yes: 'span'
}
```

Глубина вложенности подшаблонов не ограничена:

```(js)
block('link')(
    tag()('span'),
    match(this.ctx.url)(
        tag()('a'),
        attrs()({ href: this.ctx.url })
    )
)
```


### Примеры и рецепты
TODO
